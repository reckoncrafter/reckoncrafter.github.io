<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>

<link rel="stylesheet" href="stylesheet.css">

<h1 id="algorithmsstudyguide">Algorithms Study Guide</h1>

<h2 id="pandnp6subquestions">P and NP (6 sub questions)</h2>

<blockquote>
<p>Problems that have algorithms to find a solution are called <strong>decidable</strong>.</p>

<p>Problems for which no algorithm can be determine a solution are called <strong>undecidable</strong>.</p>
</blockquote>

<dl>
<dt>Polynomial Time</dt>
<dd> Describes problems for which there exists an algorithm that can solve the problem in an amount of time polynomially related to the number of inputs</dd>

<dd>Linear Search, Binary Search, Insertion Sort, Merge Sort, Matrix Multiplication</dd>

<dt>Exponential Time</dt>
<dd> Describes problems for which an algorithm exists with an exponential runtime related to the number of inputs.</dd>

<dd>Traveling Salesperson, Graph Coloring</dd>

<dt>Nondeterministic Polynomial Time</dt>
<dd> Problems that can be verified in polynomial time, but not solved.</dd>

<dd>Problems that can be verified by a deterministic Turing Machine in polynomial time, and only solved by a nondeterministic Turing Machine in polynomial time.</dd>

<dt>NP-Hard</dt>
<dd> Every problem in NP can be reduced to a problem in the NP-Hard set</dd>

<dd> The reduction algorithm is in polynomial time.</dd>

<dd>If one NP-Hard problem can be solved with the reduction algorithm, all NP problems can be solved.</dd>

<dt>NP-Complete</dt>
<dd> NP-Hard problems that have a nondeterministic polynomial time algorithm.</dd>

<dd>A problem is NP-complete if it is in NP, and every problem in NP can be reduced to it.</dd>

<dt>Boolean Satisfiability</dt>
<dd>A problem is <em>satisfiable</em> if it evaluates to TRUE for some assignment to its variables.</dd>

<dt>Optimization Problems</dt>
<dd> Asks for an optimal solution to a given problem</dd>

<dd>0&#8211;1 Knapsack, Minimum Spanning Trees, Optimal Binary Search Trees</dd>

<dt>Decision Problems</dt>
<dd>A decision problem is one with a yes or no answer</dd>
</dl>

<h2 id="dynamicprogramming2questions">Dynamic Programming (2 questions)</h2>

<p>Dynamic Programming algorithms are built on recursion. Specifically, problems are broken into sub problems that are identical.</p>

<dl>
<dt>Top Down</dt>
<dd>DP algorithms memoize as they work, storing intermediate results while the logic of the algorithms recurses down the set of inputs.</dd>

<dt>Bottom Up</dt>
<dd>DP algorithms use Tabulation, they begin at the smallest sub problems, and use the results they generate to compute the higher-order sub-problems.</dd>

<dt>The Principle of Optimality</dt>
<dd>states that for a problem to have an optimal solution by dynamic programming, then there must be an optimal solution to all sub-problems.</dd>
</dl>

<blockquote>
<p><strong>Note!</strong>
all the &#8220;by hand&#8221; algorithms listed here are bottom-up algorithms that use tabulation.
most of the problems have similarly performing or better performing top-down algorithms
that use recursion, but such algorithms are typically not ideal for working by hand.</p>
</blockquote>

<h3 id="topicscovered">topics covered</h3>

<h4 id="binomialcoefficientproblem">Binomial Coefficient Problem</h4>

<p>Given two integer values, n and k, one must find the <strong>Binomial Coefficient</strong> of n and k.</p>

<p>The binomial coefficient can be defined as the number of ways that <strong>k</strong> objects can be selected from a collection of <strong>n</strong> objects.</p>

<p><strong>Computation by Hand</strong>:</p>

<ul>
<li>lay down table of length (k+1) and width (n+1)</li>
<li>each cell represents an answer to the question &#8220;what is the Binomial Coefficient of i and j?&#8221;, with i being the row, and j being the column.</li>
<li>fill in by the following ruls:

<ul>
<li>if the current column is 0, or is equal to the current row, set to <strong>1</strong>.</li>
<li>otherwise, set the current value to be <strong>the cell 1 up and to the left</strong> plus <strong>the cell 1 up</strong></li>
</ul></li>
</ul>

<blockquote>
<p><strong>Note!</strong>
This is actually just a confusing description of how to construct <strong>Pascal&#8217;s Triangle</strong></p>

<p>If you want to find the binomial coefficient of <strong>n and k</strong>, take the <strong>kth</strong> number from the
left in the <strong>nth</strong> row of Pascal&#8217;s Triangle.</p>
</blockquote>

<p>Here&#8217;s a Pascal&#8217;s Triangle just for you :)</p>

<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Pascal%27s_triangle_5.svg/200px-Pascal%27s_triangle_5.svg.png" alt="" />
<figcaption></figcaption>
</figure>

<h4 id="matrix-chainmultiplicationminimummultiplicationsalgorithm">Matrix-chain Multiplication / Minimum Multiplications Algorithm</h4>

<p>Given a set of matricies of different dimensions, one must find the optimal order in which to multiply the matricies.</p>

<p>Matrix multiplication is commutative, as in, AB = BA, but the number of individual calculations required to compute the result, is not.</p>

<p>Take A.10x30, B.30x5, and C.5x60</p>

<ul>
<li>(AB)C = 4500 operations</li>
<li>A(BC) = 27000 operations</li>
</ul>

<p><strong>Computation by Hand</strong>:</p>

<ul>
<li>lay down a table of size <strong>nxn</strong> where <strong>n</strong> is the number of matricies</li>
<li>set all cells in the main diagonal to 0</li>
<li>ignore all cells beneath the diagonal</li>
<li>compute diagonally, where each iteration is along the diagonal one to the right of the last.</li>
<li>the first diagonal is the <strong>cost of computing the row&#8217;s matrix with the column&#8217;s matrix</strong>.</li>
<li>for each subsequent diagonal

<ul>
<li>for each cell

<ul>
<li>begin with the cell immediately to the left, and furthest to the bottom of the current cell</li>
<li>add the cells together</li>
<li>add the cost of computing the two components</li>
<li>move to the cells one further to the left, and one closer from the bottom.</li>
</ul></li>
<li>repeat until all costs have been calculated, and take the minimum.</li>
</ul></li>
</ul>

<table>
<colgroup>
<col />
<col />
<col />
<col />
</colgroup>

<thead>
<tr>
	<th> * </th>
	<th> A </th>
	<th> B </th>
	<th> C </th>
</tr>
</thead>

<tbody>
<tr>
	<td> A </td>
	<td> 0 </td>
	<td>1500</td>
	<td>4500</td>
</tr>
<tr>
	<td> B </td>
	<td> * </td>
	<td> 0 </td>
	<td>9000</td>
</tr>
<tr>
	<td> C </td>
	<td> * </td>
	<td> * </td>
	<td> 0 </td>
</tr>
</tbody>
</table>

<ul>
<li>AB: 10x30x5 == 1500</li>
<li>BC: 30x5x60 == 9000</li>
<li>(AB)C: 1500 + 0 + (10x5x60: 3000) == <strong>4500</strong></li>
<li>A(BC): 0 + 9000 + (10x30x60: 18000) == 27000</li>
</ul>

<blockquote>
<ul>
<li>minimum: 4500</li>
<li>order: (AB)C</li>
</ul>
</blockquote>

<h4 id="0-1knapsackproblem">0&#8211;1 Knapsack Problem</h4>

<p>Given a knapsack with a capacity <strong>W</strong>, and a set of items each with a given weight <strong>w</strong>, and a given value <strong>v</strong>, one must find the set of items that maximize value while staying under or equal to the capacity.</p>

<p><strong>Computation by Hand</strong>:</p>

<ul>
<li>lay down table of width <strong>W</strong>, and length <strong>i</strong> (the total number of items)</li>
<li>each cell represents an answer to the question &#8220;what is the optimal value using <strong>i</strong> items and a capacity of <strong>w</strong>?&#8221;</li>
<li>trivially, the row with 0 items and the column with 0 capacity is all 0.</li>
<li>calculating by row, fill in by the following rules:

<ul>
<li>if the weight of the item of the current row is greater than the current capcity (column), then set the cell to the value of the cell immediately above.</li>
<li>otherwise, set the cell to <strong>the cell above</strong> or <strong>the cell one row above, and the column at current capcity (column) minus the current item weight (row), plus the value of the current item</strong>, whichever is larger.</li>
</ul></li>
</ul>

<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Knapsack_problem_dynamic_programming.gif/220px-Knapsack_problem_dynamic_programming.gif" alt="" />
<figcaption></figcaption>
</figure>

<h4 id="longestcommonsubsequence">Longest Common Subsequence</h4>

<p>Given a set of sequences, typically exemplified by strings of characters, one must find the longest subsequence that occurs in all of them.</p>

<p>The following is an algorithm to compare two strings, for subsequent strings, use the resulting subsequence in another iteration of the algorithm as one of the input strings.</p>

<p><strong>Computation by Hand</strong>:</p>

<ul>
<li>lay down a table of size <strong>n+1 x k+1</strong>, where <strong>n</strong> is the length of the first string, and <strong>k</strong> is the length of the second</li>
<li>label the rows with the elements of the first sequence, starting with a null value called &epsilon;.</li>
<li>label the columns with the elements of the second sequence, also starting with &epsilon;</li>
<li>fill in the &epsilon; row and column with &epsilon;s.</li>
<li>filling in by row, if the row and column element match

<ul>
<li>concatenate the element to the entry from the cell above, and the cell to the left.</li>
<li>these can be combined if they are still equal, or joined with an ampersand, if they are of equal length</li>
<li>otherwise, write the longer one.</li>
</ul></li>
<li>if the row and column do not match

<ul>
<li>take the values from the above and left cells, removing any redundancy, and taking the longest of the two, or both if they are equal.</li>
</ul></li>
<li>the last cell will contain either the longest common subsequence, or multiple common subsequences of the same maximum length.</li>
</ul>

<p>see Wikipedia&#8217;s <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence#Worked_example">worked example</a></p>

<h4 id="optimalbinarysearchtrees">Optimal Binary Search Trees</h4>

<p>Given a set of items, and a corresponding set of probabilities, one must construct a binary search
tree that minimizes the overall cost of searching by placing items more likely to be accessed
closer to the root of the tree.</p>

<blockquote>
<p><strong>Note!</strong>
This problem is nearly identical to the one solved by Huffman Coding, and can thus be
solved by following a nearly identical algorithm.</p>

<p>Huffman coding is conceptually pretty simple, and the <a href="https://en.wikipedia.org/wiki/Huffman_coding">Wikipedia article</a>
does a good job explaining it.</p>
</blockquote>

<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/HuffmanCodeAlg.png/220px-HuffmanCodeAlg.png" alt="" />
<figcaption></figcaption>
</figure>

<h4 id="floyd-warshallalgorithm">Floyd-Warshall Algorithm</h4>

<p>Finds the shortest path between <strong>all</strong> nodes, including negative edges.</p>

<p><strong>Computation by Hand</strong>:</p>

<ul>
<li>lay down a table of size <strong>v x v</strong> where v is the number of verticies.</li>
<li>each cell is an answer to the question &#8220;what is the minimum distance between the ith vertex and jth vertex?&#8221;.</li>
<li>initialize every value in the table to infinity. (at least conceptually)</li>
<li>for each edge in the graph, set the cell that corresponds to that edge to the weight of that edge

<ul>
<li>source vertex row, destination vertex column</li>
</ul></li>
<li>set each cell where i = j to 0.</li>
<li>for k in range 1 to the number of verticies (|V|)

<ul>
<li>for i in range 1 to |V|

<ul>
<li>for j in range 1 to |V|

<ul>
<li>if the cell at <strong>row i, columnn j</strong> is greater than cell <strong>row i, column j</strong> plus <strong>row k, column j</strong>

<ul>
<li>set cell <strong>row i, column j</strong> to that sum.</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>The detection of negative cycles naturally falls out of this algorithm, as the only way any
distance between a vertex and itself can be improved from 0, is if it is part of a negative cycle,
thus if the algorithm changes one of these diagonal values, there must be a negative cycle.</p>

<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Floyd-Warshall_example.svg/600px-Floyd-Warshall_example.svg.png" alt="" />
<figcaption></figcaption>
</figure>

<h4 id="bellman-fordalgorithm">Bellman-Ford Algorithm</h4>

<p>Finds the shortest path from <strong>one</strong> node to all nodes, including negative edges.</p>

<p>Similarly to the Floyd-Warshall algorithm, I can&#8217;t really describe a way to do this by hand that isn&#8217;t just the pseudocode for the algorithm, so just use the <a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm#Algorithm">pseudocode</a>.</p>

<figure>
<img src="http://www.programming-algorithms.net/image/id/47416" alt="" />
<figcaption></figcaption>
</figure>

<h2 id="greedyalgorithms3questions2multiple-choice">Greedy Algorithms (3 questions + 2 multiple-choice)</h2>

<h4 id="dijkstrasalgorithm">Dijkstra&#8217;s Algorithm</h4>

<p>Finds the shortest path between two nodes with only positive edges.</p>

<p><strong>Computation by Hand</strong>:</p>

<ul>
<li>Begin by labeling each node with a distance.

<ul>
<li>0 for the start node</li>
<li>the edge weight for each node adjacent to the starting node</li>
<li>infinity for all other nodes</li>
</ul></li>
<li>Proceed by selecting the closest adjacent node

<ul>
<li>update nodes adjacent to this node by adding this node&#8217;s current distance to the adjacent&#8217;s edge weight, <strong>only if the new distance is shorter</strong>.</li>
</ul></li>
<li>Repeat this for all other nodes, in a breadth-first manner, completing all nodes i edges away from the origin, before doing the closest nodes i+1 edges away from the origin.</li>
<li>At the end of this process, each node will be labeled with its shortest distance to the origin.</li>
</ul>

<figure>
<img src="https://ds055uzetaobb.cloudfront.net/brioche/uploads/lessons/dijkstra-EQ50NN.gif" alt="" />
<figcaption></figcaption>
</figure>

<h4 id="o-1knapsackproblem">O-1 Knapsack Problem</h4>

<p>There is no <strong>optimal</strong> greedy algorithm for the 0&#8211;1 Knapsack Problem, but there do exist greedy <strong>approximation</strong> algorithms that will be faster than the optimal DP algorithm.</p>

<p><strong>Computation by Hand</strong>:</p>

<ul>
<li>Sort the items in decreasing order of value per unit weight. i.e. <span class="math">\(v_1 / w_1 &gt;= v_2 / w_2 ...\)</span></li>
<li>Insert them into the sack in order.</li>
<li>If the problem is <strong>unbounded</strong>, meaning one can insert as many copies of a single item as one desires, then this algorithm will yield a maximum at least half of the optimal maximum.</li>
<li>If the problem is <strong>bounded</strong>, meaning only one copy of each item exists, then take the set of items created by the algorithm (S_1), and a set containing the first item that didn&#8217;t fit (S_2).</li>
<li>One of these sets will have a value of at least half of the optimal value, assuming each item individually fits into the sack.</li>
</ul>

<h4 id="primsalgorithmkruskalsalgorithmminimumspanningtrees">Prim&#8217;s Algorithm / Kruskal&#8217;s Algorithm / Minimum Spanning Trees</h4>

<blockquote>
<p>For complete or nearly complete graphs, <strong>Prim&#8217;s Algorithm</strong> performs faster. <span class="math">\(O(E\log V)\)</span></p>

<p>If the graph is spars, or has few edges, <strong>Kruskal&#8217;s Algorithm</strong> gives <span class="math">\(O(E\log E)\)</span></p>
</blockquote>

<p><strong>Prim&#8217;s Algorithm by Hand</strong>:</p>

<ul>
<li>Arbitrarily select a node from the graph</li>
<li>Of the edges that connect to verticies not in the tree

<ul>
<li>Add the minimum edge to the tree</li>
</ul></li>
<li>Repeat until all verticies are in the tree.</li>
</ul>

<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/PrimAlgDemo.gif/200px-PrimAlgDemo.gif" alt="" />
<figcaption></figcaption>
</figure>

<p><strong>Kruskal&#8217;s Algorithm by Hand</strong>:</p>

<ul>
<li>Conceptualize each vertex as the root of a new tree. i.e. A forest</li>
<li>Sort all edges of the graph by weight</li>
<li>For each edge in the sortest list, starting with the smallest

<ul>
<li>Add the edge to the forest, if <strong>adding it will not create a cycle</strong>.</li>
</ul></li>
</ul>

<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/KruskalDemo.gif/300px-KruskalDemo.gif" alt="" />
<figcaption></figcaption>
</figure>

<p>Kruskal&#8217;s algorithm will always generate a minimum spanning <strong>forest</strong>, unless the graph is
<strong>connected</strong>, where it will generate a minimum spanning tree.</p>

<h4 id="maximumflowminimumcut">Maximum Flow / Minimum Cut</h4>

<blockquote>
<p>The max-flow min-cut theorem states that, in a flow network, the maximum amount of flow passing
from the <em>source</em> to the <em>sink</em> is equal to the total weight of the edges in a minimum cut, the
smallest total weight of the edges, which if removed from the network, would disconnect the
source from the sink.</p>
</blockquote>

<p><strong>Ford-Fulkerson Algorithm by Hand</strong>:</p>

<ul>
<li>Given a source node <strong>s</strong>, and sink node <strong>t</strong></li>
<li>Each edge in the graph begins with a <strong>flow</strong> of 0.</li>
<li>For each possible path between <strong>s</strong> and <strong>t</strong>

<ul>
<li>Find the minimum edge along the path, this is the total flow of the path. (<strong>f</strong>)</li>
<li>For each edge (u, v) in the path

<ul>
<li>Set the <strong>flow</strong> from <strong>u to v</strong> to the current flow(u, v) + <strong>f</strong></li>
<li>Set the <strong>flow</strong> from <strong>v to u</strong> to the current flow(v, u) - <strong>f</strong></li>
</ul></li>
</ul></li>
</ul>

<figure>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*UCb45MFbnUXqn-U2_qWtLQ.gif" alt="" />
<figcaption></figcaption>
</figure>

</body>
</html>

